
Maze_solver_16.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000622  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .debug_aranges 00000020  00000000  00000000  00000676  2**0
                  CONTENTS, READONLY, DEBUGGING
  2 .debug_pubnames 0000001b  00000000  00000000  00000696  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_info   00000a20  00000000  00000000  000006b1  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_abbrev 000001aa  00000000  00000000  000010d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_line   000009ca  00000000  00000000  0000127b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_frame  00000020  00000000  00000000  00001c48  2**2
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_str    0000012a  00000000  00000000  00001c68  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000008a5  00000000  00000000  00001d92  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_ranges 00000408  00000000  00000000  00002637  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e2 e2       	ldi	r30, 0x22	; 34
  68:	f6 e0       	ldi	r31, 0x06	; 6
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	a0 36       	cpi	r26, 0x60	; 96
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	a0 e6       	ldi	r26, 0x60	; 96
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a0 36       	cpi	r26, 0x60	; 96
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 49 00 	call	0x92	; 0x92 <main>
  8a:	0c 94 0f 03 	jmp	0x61e	; 0x61e <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <main>:
*/

#include<avr/io.h>
#include<util/delay.h>
int main()
{
  92:	2f 92       	push	r2
  94:	3f 92       	push	r3
  96:	4f 92       	push	r4
  98:	5f 92       	push	r5
  9a:	6f 92       	push	r6
  9c:	7f 92       	push	r7
  9e:	8f 92       	push	r8
  a0:	9f 92       	push	r9
  a2:	af 92       	push	r10
  a4:	bf 92       	push	r11
  a6:	cf 92       	push	r12
  a8:	df 92       	push	r13
  aa:	ef 92       	push	r14
  ac:	ff 92       	push	r15
  ae:	0f 93       	push	r16
  b0:	1f 93       	push	r17
  b2:	df 93       	push	r29
  b4:	cf 93       	push	r28
  b6:	cd b7       	in	r28, 0x3d	; 61
  b8:	de b7       	in	r29, 0x3e	; 62
  ba:	64 97       	sbiw	r28, 0x14	; 20
  bc:	0f b6       	in	r0, 0x3f	; 63
  be:	f8 94       	cli
  c0:	de bf       	out	0x3e, r29	; 62
  c2:	0f be       	out	0x3f, r0	; 63
  c4:	cd bf       	out	0x3d, r28	; 61
	 * 'u' => U-turn
	 * 's' => straight
	 * 'e' => end of maze!!
	*/
	unsigned char checker;		//to check if a u turn is recorded motors as outputs
	DDRD |= (1<<4)|(1<<5)|(1<<6)|(1<<7); //beeper as output
  c6:	81 b3       	in	r24, 0x11	; 17
  c8:	80 6f       	ori	r24, 0xF0	; 240
  ca:	81 bb       	out	0x11, r24	; 17
	DDRC |= (1<<3);	
  cc:	a3 9a       	sbi	0x14, 3	; 20
	DDRA &= (~((1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4))); 	//enable pullup
  ce:	8a b3       	in	r24, 0x1a	; 26
  d0:	80 7e       	andi	r24, 0xE0	; 224
  d2:	8a bb       	out	0x1a, r24	; 26
	PORTA |= (1<<0)|(1<<1)|(1<<2)|(1<<3)|(1<<4);
  d4:	8b b3       	in	r24, 0x1b	; 27
  d6:	8f 61       	ori	r24, 0x1F	; 31
  d8:	8b bb       	out	0x1b, r24	; 27
  da:	01 e0       	ldi	r16, 0x01	; 1
  dc:	10 e0       	ldi	r17, 0x00	; 0
  de:	21 e0       	ldi	r18, 0x01	; 1
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	40 e0       	ldi	r20, 0x00	; 0
  e4:	50 e0       	ldi	r21, 0x00	; 0
  e6:	ee 24       	eor	r14, r14
  e8:	ff 24       	eor	r15, r15
					PORTD |= (1<<5)|(1<<7);
					PORTD &= (~((1<<4)|(1<<6)));
					_delay_ms(1);
					continue;
				}
				directions[counter123] = 'u';
  ea:	be 01       	movw	r22, r28
  ec:	6f 5f       	subi	r22, 0xFF	; 255
  ee:	7f 4f       	sbci	r23, 0xFF	; 255
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
  f0:	8a ef       	ldi	r24, 0xFA	; 250
  f2:	88 2e       	mov	r8, r24
  f4:	91 2c       	mov	r9, r1
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
  f6:	ba e6       	ldi	r27, 0x6A	; 106
  f8:	6b 2e       	mov	r6, r27
  fa:	b8 e1       	ldi	r27, 0x18	; 24
  fc:	7b 2e       	mov	r7, r27
  fe:	a3 e0       	ldi	r26, 0x03	; 3
 100:	ba 2e       	mov	r11, r26
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 102:	a9 e1       	ldi	r26, 0x19	; 25
 104:	b0 e0       	ldi	r27, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 106:	f6 ed       	ldi	r31, 0xD6	; 214
 108:	cf 2e       	mov	r12, r31
 10a:	f6 e0       	ldi	r31, 0x06	; 6
 10c:	df 2e       	mov	r13, r31
 10e:	e4 ef       	ldi	r30, 0xF4	; 244
 110:	2e 2e       	mov	r2, r30
 112:	e1 e0       	ldi	r30, 0x01	; 1
 114:	3e 2e       	mov	r3, r30
 116:	96 e0       	ldi	r25, 0x06	; 6
 118:	a9 2e       	mov	r10, r25
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 11a:	82 ee       	ldi	r24, 0xE2	; 226
 11c:	48 2e       	mov	r4, r24
 11e:	84 e0       	ldi	r24, 0x04	; 4
 120:	58 2e       	mov	r5, r24
	
	while(1)
	{
		
		{								//block to assign status to num
			if((PINA & (1<<0)) != 0)
 122:	c8 9b       	sbis	0x19, 0	; 25
 124:	03 c0       	rjmp	.+6      	; 0x12c <main+0x9a>
			{
				num &= (~(1<<4));
 126:	c8 01       	movw	r24, r16
 128:	8f 7e       	andi	r24, 0xEF	; 239
 12a:	02 c0       	rjmp	.+4      	; 0x130 <main+0x9e>
			}
			else
			{
				num |= (1<<4);
 12c:	c8 01       	movw	r24, r16
 12e:	80 61       	ori	r24, 0x10	; 16
			}


			if((PINA & (1<<1)) != 0)
 130:	c9 9b       	sbis	0x19, 1	; 25
 132:	02 c0       	rjmp	.+4      	; 0x138 <main+0xa6>
			{
				num &= (~(1<<3));
 134:	87 7f       	andi	r24, 0xF7	; 247
 136:	01 c0       	rjmp	.+2      	; 0x13a <main+0xa8>
			}
			else
			{
				num |= (1<<3);
 138:	88 60       	ori	r24, 0x08	; 8
			}

			if((PINA & (1<<2)) != 0)
 13a:	ca 9b       	sbis	0x19, 2	; 25
 13c:	02 c0       	rjmp	.+4      	; 0x142 <main+0xb0>
			{
				num &= (~(1<<2));
 13e:	8b 7f       	andi	r24, 0xFB	; 251
 140:	01 c0       	rjmp	.+2      	; 0x144 <main+0xb2>
			}
			else
			{
				num |= (1<<2);
 142:	84 60       	ori	r24, 0x04	; 4
			}

			if((PINA & (1<<3)) != 0)
 144:	cb 9b       	sbis	0x19, 3	; 25
 146:	02 c0       	rjmp	.+4      	; 0x14c <main+0xba>
			{
				num &= (~(1<<1));
 148:	8d 7f       	andi	r24, 0xFD	; 253
 14a:	01 c0       	rjmp	.+2      	; 0x14e <main+0xbc>
			}
			else
			{
				num |= (1<<1);
 14c:	82 60       	ori	r24, 0x02	; 2
			}

			if((PINA & (1<<4)) != 0)
 14e:	cc 9b       	sbis	0x19, 4	; 25
 150:	03 c0       	rjmp	.+6      	; 0x158 <main+0xc6>
			{
				num &= (~(1<<0));
 152:	8c 01       	movw	r16, r24
 154:	0e 7f       	andi	r16, 0xFE	; 254
 156:	02 c0       	rjmp	.+4      	; 0x15c <main+0xca>
			}
			else
			{
				num |= (1<<0);
 158:	8c 01       	movw	r16, r24
 15a:	01 60       	ori	r16, 0x01	; 1
			}
		}					//end of status assigning block
		

		{  //line following code
			if(num == 4)
 15c:	04 30       	cpi	r16, 0x04	; 4
 15e:	11 05       	cpc	r17, r1
 160:	71 f4       	brne	.+28     	; 0x17e <main+0xec>
			{
				//00100->full speed forward
				PORTD |= (1<<5)|(1<<7);
 162:	82 b3       	in	r24, 0x12	; 18
 164:	80 6a       	ori	r24, 0xA0	; 160
 166:	82 bb       	out	0x12, r24	; 18
				PORTD &= (~((1<<4)|(1<<6)));
 168:	82 b3       	in	r24, 0x12	; 18
 16a:	8f 7a       	andi	r24, 0xAF	; 175
 16c:	82 bb       	out	0x12, r24	; 18
 16e:	c6 01       	movw	r24, r12
 170:	01 97       	sbiw	r24, 0x01	; 1
 172:	f1 f7       	brne	.-4      	; 0x170 <main+0xde>
				_delay_ms(7);
				PORTD = 0x00;
 174:	12 ba       	out	0x12, r1	; 18
 176:	c2 01       	movw	r24, r4
 178:	01 97       	sbiw	r24, 0x01	; 1
 17a:	f1 f7       	brne	.-4      	; 0x178 <main+0xe6>
 17c:	48 c0       	rjmp	.+144    	; 0x20e <main+0x17c>
				_delay_ms(5);
			}
			else if((num == 12) || (num == 8))
 17e:	0c 30       	cpi	r16, 0x0C	; 12
 180:	11 05       	cpc	r17, r1
 182:	19 f0       	breq	.+6      	; 0x18a <main+0xf8>
 184:	08 30       	cpi	r16, 0x08	; 8
 186:	11 05       	cpc	r17, r1
 188:	49 f4       	brne	.+18     	; 0x19c <main+0x10a>
			{
				//01100 or 01000->take a mild left
				PORTD |= (1<<5);
 18a:	95 9a       	sbi	0x12, 5	; 18
				PORTD &= (~(1<<4));
 18c:	94 98       	cbi	0x12, 4	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 18e:	8b 2d       	mov	r24, r11
 190:	8a 95       	dec	r24
 192:	f1 f7       	brne	.-4      	; 0x190 <main+0xfe>
				_delay_us(10);
				PORTD = 0x00;
 194:	12 ba       	out	0x12, r1	; 18
				PORTD |= (1<<7);
 196:	97 9a       	sbi	0x12, 7	; 18
				PORTD &= (~(1<<6));
 198:	96 98       	cbi	0x12, 6	; 18
 19a:	0e c0       	rjmp	.+28     	; 0x1b8 <main+0x126>
				_delay_us(20);
				PORTD = 0x00;
			}
			else if((num == 2) || (num == 6))
 19c:	02 30       	cpi	r16, 0x02	; 2
 19e:	11 05       	cpc	r17, r1
 1a0:	19 f0       	breq	.+6      	; 0x1a8 <main+0x116>
 1a2:	06 30       	cpi	r16, 0x06	; 6
 1a4:	11 05       	cpc	r17, r1
 1a6:	61 f4       	brne	.+24     	; 0x1c0 <main+0x12e>
			{
				//00010 or 00110->Take a mild right
				PORTD |= (1<<7);
 1a8:	97 9a       	sbi	0x12, 7	; 18
				PORTD &= (~(1<<6));
 1aa:	96 98       	cbi	0x12, 6	; 18
 1ac:	8b 2d       	mov	r24, r11
 1ae:	8a 95       	dec	r24
 1b0:	f1 f7       	brne	.-4      	; 0x1ae <main+0x11c>
				_delay_us(10);
				PORTD = 0x00;
 1b2:	12 ba       	out	0x12, r1	; 18
				PORTD |= (1<<5);
 1b4:	95 9a       	sbi	0x12, 5	; 18
				PORTD &= (~(1<<4));
 1b6:	94 98       	cbi	0x12, 4	; 18
 1b8:	8a 2d       	mov	r24, r10
 1ba:	8a 95       	dec	r24
 1bc:	f1 f7       	brne	.-4      	; 0x1ba <main+0x128>
				_delay_us(20);
				PORTD = 0x00;
 1be:	12 ba       	out	0x12, r1	; 18
			}
			
		}	//end of line following code
		
		{		//turns and intersection
			if((num == 28) || (num == 24))
 1c0:	0c 31       	cpi	r16, 0x1C	; 28
 1c2:	11 05       	cpc	r17, r1
 1c4:	19 f0       	breq	.+6      	; 0x1cc <main+0x13a>
 1c6:	08 31       	cpi	r16, 0x18	; 24
 1c8:	11 05       	cpc	r17, r1
 1ca:	f1 f4       	brne	.+60     	; 0x208 <main+0x176>
 1cc:	80 e1       	ldi	r24, 0x10	; 16
 1ce:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 1d0:	fd 01       	movw	r30, r26
 1d2:	31 97       	sbiw	r30, 0x01	; 1
 1d4:	f1 f7       	brne	.-4      	; 0x1d2 <main+0x140>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 1d6:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 1d8:	d9 f7       	brne	.-10     	; 0x1d0 <main+0x13e>
			{
				//left turn
				_delay_ms(1000);
				//go ahead a bit
				PORTD |= (1<<5)|(1<<7);
 1da:	82 b3       	in	r24, 0x12	; 18
 1dc:	80 6a       	ori	r24, 0xA0	; 160
 1de:	82 bb       	out	0x12, r24	; 18
				PORTD &= (~((1<<4)|(1<<6)));
 1e0:	82 b3       	in	r24, 0x12	; 18
 1e2:	8f 7a       	andi	r24, 0xAF	; 175
 1e4:	82 bb       	out	0x12, r24	; 18
 1e6:	c6 01       	movw	r24, r12
 1e8:	01 97       	sbiw	r24, 0x01	; 1
 1ea:	f1 f7       	brne	.-4      	; 0x1e8 <main+0x156>
				_delay_ms(07);
				PORTD = 0x00;
 1ec:	12 ba       	out	0x12, r1	; 18
				//now take a turn till middle sensor is on black again...
				while(1)
				{
					PORTD |= (1<<7);
 1ee:	97 9a       	sbi	0x12, 7	; 18
					PORTD &= (~(1<<6));
 1f0:	96 98       	cbi	0x12, 6	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 1f2:	8b 2d       	mov	r24, r11
 1f4:	8a 95       	dec	r24
 1f6:	f1 f7       	brne	.-4      	; 0x1f4 <main+0x162>
					_delay_us(10);
					PORTD = 0x00;
 1f8:	12 ba       	out	0x12, r1	; 18
					if((PINA & (1<<2)) == 0)
 1fa:	ca 99       	sbic	0x19, 2	; 25
 1fc:	f8 cf       	rjmp	.-16     	; 0x1ee <main+0x15c>
						break;		//break out of while loop
				}		//left turn completed!!!
				//record this turn now....
				directions[counter123] = 'l';
 1fe:	fb 01       	movw	r30, r22
 200:	ee 0d       	add	r30, r14
 202:	ff 1d       	adc	r31, r15
 204:	8c e6       	ldi	r24, 0x6C	; 108
 206:	54 c0       	rjmp	.+168    	; 0x2b0 <main+0x21e>
				
			}
			
			//<!--------------EDIT-------------!>
			
			else if((num == 7) || (num == 3))
 208:	07 30       	cpi	r16, 0x07	; 7
 20a:	11 05       	cpc	r17, r1
 20c:	21 f0       	breq	.+8      	; 0x216 <main+0x184>
 20e:	03 30       	cpi	r16, 0x03	; 3
 210:	11 05       	cpc	r17, r1
 212:	09 f0       	breq	.+2      	; 0x216 <main+0x184>
 214:	57 c0       	rjmp	.+174    	; 0x2c4 <main+0x232>
 216:	80 e1       	ldi	r24, 0x10	; 16
 218:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 21a:	fd 01       	movw	r30, r26
 21c:	31 97       	sbiw	r30, 0x01	; 1
 21e:	f1 f7       	brne	.-4      	; 0x21c <main+0x18a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 220:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 222:	d9 f7       	brne	.-10     	; 0x21a <main+0x188>
			{
				//can be a right only turn or a straight-right intersection
				//move forward a bit
				_delay_ms(1000);
				PORTD |= (1<<5)|(1<<7);
 224:	82 b3       	in	r24, 0x12	; 18
 226:	80 6a       	ori	r24, 0xA0	; 160
 228:	82 bb       	out	0x12, r24	; 18
				PORTD &= (~((1<<4)|(1<<6)));
 22a:	82 b3       	in	r24, 0x12	; 18
 22c:	8f 7a       	andi	r24, 0xAF	; 175
 22e:	82 bb       	out	0x12, r24	; 18
 230:	c3 01       	movw	r24, r6
 232:	01 97       	sbiw	r24, 0x01	; 1
 234:	f1 f7       	brne	.-4      	; 0x232 <main+0x1a0>
				_delay_ms(25);
				PORTD = 0x00;
 236:	12 ba       	out	0x12, r1	; 18
 238:	80 e1       	ldi	r24, 0x10	; 16
 23a:	97 e2       	ldi	r25, 0x27	; 39
 23c:	fd 01       	movw	r30, r26
 23e:	31 97       	sbiw	r30, 0x01	; 1
 240:	f1 f7       	brne	.-4      	; 0x23e <main+0x1ac>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 242:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 244:	d9 f7       	brne	.-10     	; 0x23c <main+0x1aa>
				//scan sensors again
				_delay_ms(1000);
		
				if((PINA & (1<<0)) != 0)
 246:	c8 9b       	sbis	0x19, 0	; 25
 248:	3d c0       	rjmp	.+122    	; 0x2c4 <main+0x232>
					if((PINA & (1<<1)) != 0)
 24a:	c9 9b       	sbis	0x19, 1	; 25
 24c:	3b c0       	rjmp	.+118    	; 0x2c4 <main+0x232>
						if((PINA & (1<<2)) != 0)
 24e:	ca 9b       	sbis	0x19, 2	; 25
 250:	39 c0       	rjmp	.+114    	; 0x2c4 <main+0x232>
							if((PINA & (1<<3)) != 0)
 252:	cb 9b       	sbis	0x19, 3	; 25
 254:	37 c0       	rjmp	.+110    	; 0x2c4 <main+0x232>
								if((PINA & (1<<4)) != 0)
 256:	cc 9b       	sbis	0x19, 4	; 25
 258:	30 c0       	rjmp	.+96     	; 0x2ba <main+0x228>
								{
									//was a right only turn
									//move back for 20ms
									PORTD |= (1<<4)|(1<<6);
 25a:	82 b3       	in	r24, 0x12	; 18
 25c:	80 65       	ori	r24, 0x50	; 80
 25e:	82 bb       	out	0x12, r24	; 18
									PORTD &= (~((1<<5)|(1<<7)));
 260:	82 b3       	in	r24, 0x12	; 18
 262:	8f 75       	andi	r24, 0x5F	; 95
 264:	82 bb       	out	0x12, r24	; 18
 266:	84 e6       	ldi	r24, 0x64	; 100
 268:	99 e1       	ldi	r25, 0x19	; 25
 26a:	01 97       	sbiw	r24, 0x01	; 1
 26c:	f1 f7       	brne	.-4      	; 0x26a <main+0x1d8>
									_delay_ms(26);
									PORTD = 0x00;
 26e:	12 ba       	out	0x12, r1	; 18
 270:	80 e1       	ldi	r24, 0x10	; 16
 272:	97 e2       	ldi	r25, 0x27	; 39
 274:	fd 01       	movw	r30, r26
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	f1 f7       	brne	.-4      	; 0x276 <main+0x1e4>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 27a:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 27c:	d9 f7       	brne	.-10     	; 0x274 <main+0x1e2>
									_delay_ms(1000);
									PORTD |= (1<<5)|(1<<6);
 27e:	82 b3       	in	r24, 0x12	; 18
 280:	80 66       	ori	r24, 0x60	; 96
 282:	82 bb       	out	0x12, r24	; 18
									PORTD &= (~((1<<4)|(1<<7)));
 284:	82 b3       	in	r24, 0x12	; 18
 286:	8f 76       	andi	r24, 0x6F	; 111
 288:	82 bb       	out	0x12, r24	; 18
 28a:	c6 01       	movw	r24, r12
 28c:	01 97       	sbiw	r24, 0x01	; 1
 28e:	f1 f7       	brne	.-4      	; 0x28c <main+0x1fa>
									_delay_ms(7);
									PORTD = 0x00;
 290:	12 ba       	out	0x12, r1	; 18
							
									//now take a right
							
										while(1)
										{
											PORTD |= (1<<5);
 292:	95 9a       	sbi	0x12, 5	; 18
											PORTD &= (~(1<<4));
 294:	94 98       	cbi	0x12, 4	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 296:	8b 2d       	mov	r24, r11
 298:	8a 95       	dec	r24
 29a:	f1 f7       	brne	.-4      	; 0x298 <main+0x206>
											_delay_us(10);
											PORTD = 0x00;
 29c:	12 ba       	out	0x12, r1	; 18
											
											if((PINA & (1<<2)) == 0)
 29e:	ca 99       	sbic	0x19, 2	; 25
 2a0:	f8 cf       	rjmp	.-16     	; 0x292 <main+0x200>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 2a2:	c1 01       	movw	r24, r2
 2a4:	01 97       	sbiw	r24, 0x01	; 1
 2a6:	f1 f7       	brne	.-4      	; 0x2a4 <main+0x212>
											{
												_delay_ms(2);
												break;		//break out of while loop
											}
										}
										directions[counter123] = 'r';
 2a8:	fb 01       	movw	r30, r22
 2aa:	ee 0d       	add	r30, r14
 2ac:	ff 1d       	adc	r31, r15
 2ae:	82 e7       	ldi	r24, 0x72	; 114
 2b0:	80 83       	st	Z, r24
										counter123++;
 2b2:	08 94       	sec
 2b4:	e1 1c       	adc	r14, r1
 2b6:	f1 1c       	adc	r15, r1
 2b8:	05 c0       	rjmp	.+10     	; 0x2c4 <main+0x232>
								}
		
				else
				{
					//was a straight only road...
					directions[counter123] = 's';
 2ba:	fb 01       	movw	r30, r22
 2bc:	ee 0d       	add	r30, r14
 2be:	ff 1d       	adc	r31, r15
 2c0:	83 e7       	ldi	r24, 0x73	; 115
 2c2:	69 c0       	rjmp	.+210    	; 0x396 <main+0x304>
		}		//turns and intersection end
	
		{		//T-intersection,+ intersection and END
			//$$$$$$$$$$$$$$$$$$$$$$$$$-----EDIT-------$$$$$$$$$$$$$$$$$$$//
			
			if(num == 0)
 2c4:	01 15       	cp	r16, r1
 2c6:	11 05       	cpc	r17, r1
 2c8:	09 f0       	breq	.+2      	; 0x2cc <main+0x23a>
 2ca:	6a c0       	rjmp	.+212    	; 0x3a0 <main+0x30e>
			{
				//11111->intersection of the above types
				//move forward by a small amount

				PORTD |= (1<<5)|(1<<7);
 2cc:	82 b3       	in	r24, 0x12	; 18
 2ce:	80 6a       	ori	r24, 0xA0	; 160
 2d0:	82 bb       	out	0x12, r24	; 18
				PORTD &= (~((1<<4)|(1<<6)));
 2d2:	82 b3       	in	r24, 0x12	; 18
 2d4:	8f 7a       	andi	r24, 0xAF	; 175
 2d6:	82 bb       	out	0x12, r24	; 18
 2d8:	c3 01       	movw	r24, r6
 2da:	01 97       	sbiw	r24, 0x01	; 1
 2dc:	f1 f7       	brne	.-4      	; 0x2da <main+0x248>

				//re-scan sensors


					{								//block to assign status to num
						if((PINA & (1<<0)) != 0)
 2de:	c8 9b       	sbis	0x19, 0	; 25
 2e0:	03 c0       	rjmp	.+6      	; 0x2e8 <main+0x256>
						{
							num2 &= (~(1<<4));
 2e2:	c9 01       	movw	r24, r18
 2e4:	8f 7e       	andi	r24, 0xEF	; 239
 2e6:	02 c0       	rjmp	.+4      	; 0x2ec <main+0x25a>
						}
						else
						{
							num2 |= (1<<4);
 2e8:	c9 01       	movw	r24, r18
 2ea:	80 61       	ori	r24, 0x10	; 16
						}


						if((PINA & (1<<1)) != 0)
 2ec:	c9 9b       	sbis	0x19, 1	; 25
 2ee:	02 c0       	rjmp	.+4      	; 0x2f4 <main+0x262>
						{
							num2 &= (~(1<<3));
 2f0:	87 7f       	andi	r24, 0xF7	; 247
 2f2:	01 c0       	rjmp	.+2      	; 0x2f6 <main+0x264>
						}
						else
						{
							num2 |= (1<<3);
 2f4:	88 60       	ori	r24, 0x08	; 8
						}

						if((PINA & (1<<2)) != 0)
 2f6:	ca 9b       	sbis	0x19, 2	; 25
 2f8:	02 c0       	rjmp	.+4      	; 0x2fe <main+0x26c>
						{
							num2 &= (~(1<<2));
 2fa:	8b 7f       	andi	r24, 0xFB	; 251
 2fc:	01 c0       	rjmp	.+2      	; 0x300 <main+0x26e>
						}
						else
						{
							num2 |= (1<<2);
 2fe:	84 60       	ori	r24, 0x04	; 4
						}

						if((PINA & (1<<3)) != 0)
 300:	cb 9b       	sbis	0x19, 3	; 25
 302:	02 c0       	rjmp	.+4      	; 0x308 <main+0x276>
						{
							num2 &= (~(1<<1));
 304:	8d 7f       	andi	r24, 0xFD	; 253
 306:	01 c0       	rjmp	.+2      	; 0x30a <main+0x278>
						}
						else
						{
							num2 |= (1<<1);
 308:	82 60       	ori	r24, 0x02	; 2
						}

						if((PINA & (1<<4)) != 0)
 30a:	cc 9b       	sbis	0x19, 4	; 25
 30c:	06 c0       	rjmp	.+12     	; 0x31a <main+0x288>
						{
							num2 &= (~(1<<0));
 30e:	9c 01       	movw	r18, r24
 310:	2e 7f       	andi	r18, 0xFE	; 254
						{
							num2 |= (1<<0);
						}
					}					//end of status assigning block

					if(num2 == 0)
 312:	21 15       	cp	r18, r1
 314:	31 05       	cpc	r19, r1
 316:	19 f5       	brne	.+70     	; 0x35e <main+0x2cc>
 318:	03 c0       	rjmp	.+6      	; 0x320 <main+0x28e>
						{
							num2 &= (~(1<<0));
						}
						else
						{
							num2 |= (1<<0);
 31a:	9c 01       	movw	r18, r24
 31c:	21 60       	ori	r18, 0x01	; 1
 31e:	1f c0       	rjmp	.+62     	; 0x35e <main+0x2cc>

					if(num2 == 0)
					{
						//11111->stop....end of maze

						PORTD = 0x00;
 320:	12 ba       	out	0x12, r1	; 18
						PORTC |= (1<<3);			//buzzer on
 322:	ab 9a       	sbi	0x15, 3	; 21
 324:	80 e2       	ldi	r24, 0x20	; 32
 326:	9e e4       	ldi	r25, 0x4E	; 78
 328:	29 e1       	ldi	r18, 0x19	; 25
 32a:	30 e0       	ldi	r19, 0x00	; 0
 32c:	f9 01       	movw	r30, r18
 32e:	31 97       	sbiw	r30, 0x01	; 1
 330:	f1 f7       	brne	.-4      	; 0x32e <main+0x29c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 332:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 334:	d9 f7       	brne	.-10     	; 0x32c <main+0x29a>
						_delay_ms(2000);
						PORTC &= (~(1<<3));			//buzzer off
 336:	ab 98       	cbi	0x15, 3	; 21
						
						directions[counter123] = 'e';
 338:	ce 01       	movw	r24, r28
 33a:	01 96       	adiw	r24, 0x01	; 1
 33c:	fc 01       	movw	r30, r24
 33e:	ee 0d       	add	r30, r14
 340:	ff 1d       	adc	r31, r15
 342:	25 e6       	ldi	r18, 0x65	; 101
 344:	20 83       	st	Z, r18
 346:	40 e0       	ldi	r20, 0x00	; 0
 348:	50 e0       	ldi	r21, 0x00	; 0
 34a:	60 e0       	ldi	r22, 0x00	; 0
 34c:	70 e0       	ldi	r23, 0x00	; 0
		short len = counter123-1;
		short m = 0;			//loop tracking variable
		short n = 0;			//assigning variable
		for(;m<=len;m++)
		{
			if(directions[m] != 'u')
 34e:	6c 01       	movw	r12, r24
 350:	ce 01       	movw	r24, r28
 352:	0b 96       	adiw	r24, 0x0b	; 11
						path[n-1] = 's';
					}
					else if(directions[m+1] == 's')
					{
						m = m + 1;
						path[n-1] = 'r';
 354:	f2 e7       	ldi	r31, 0x72	; 114
 356:	bf 2e       	mov	r11, r31
				else if(path[n-1] == 'l')
				{
					if(directions[m+1] == 'l')
					{
						m = m + 1;
						path[n-1] = 's';
 358:	e3 e7       	ldi	r30, 0x73	; 115
 35a:	ae 2e       	mov	r10, r30
 35c:	3d c0       	rjmp	.+122    	; 0x3d8 <main+0x346>
						break;
					}		//end of "Maze-end" block
					else
					{
						//take a left as it is a default...
						PORTD |= (1<<4)|(1<<6);
 35e:	82 b3       	in	r24, 0x12	; 18
 360:	80 65       	ori	r24, 0x50	; 80
 362:	82 bb       	out	0x12, r24	; 18
						PORTD &= (~((1<<5)|(1<<7)));
 364:	82 b3       	in	r24, 0x12	; 18
 366:	8f 75       	andi	r24, 0x5F	; 95
 368:	82 bb       	out	0x12, r24	; 18
 36a:	84 e9       	ldi	r24, 0x94	; 148
 36c:	91 e1       	ldi	r25, 0x11	; 17
 36e:	01 97       	sbiw	r24, 0x01	; 1
 370:	f1 f7       	brne	.-4      	; 0x36e <main+0x2dc>
						_delay_ms(18);
						PORTD = 0x00;
 372:	12 ba       	out	0x12, r1	; 18

						while(1)
						{
							PORTD |= (1<<7);
 374:	97 9a       	sbi	0x12, 7	; 18
							PORTD &= (~((1<<4)|(1<<5)|(1<<6)));
 376:	82 b3       	in	r24, 0x12	; 18
 378:	8f 78       	andi	r24, 0x8F	; 143
 37a:	82 bb       	out	0x12, r24	; 18
 37c:	c4 01       	movw	r24, r8
 37e:	01 97       	sbiw	r24, 0x01	; 1
 380:	f1 f7       	brne	.-4      	; 0x37e <main+0x2ec>
							_delay_ms(1);
							PORTD = 0x00;
 382:	12 ba       	out	0x12, r1	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 384:	8b 2d       	mov	r24, r11
 386:	8a 95       	dec	r24
 388:	f1 f7       	brne	.-4      	; 0x386 <main+0x2f4>
							_delay_us(10);

							if((PINA & (1<<2))==0)
 38a:	ca 99       	sbic	0x19, 2	; 25
 38c:	f3 cf       	rjmp	.-26     	; 0x374 <main+0x2e2>
							{
								break;		//break out of while loop
							}
						}
						directions[counter123] = 'l';
 38e:	fb 01       	movw	r30, r22
 390:	ee 0d       	add	r30, r14
 392:	ff 1d       	adc	r31, r15
 394:	8c e6       	ldi	r24, 0x6C	; 108
 396:	80 83       	st	Z, r24
						counter123++;
 398:	08 94       	sec
 39a:	e1 1c       	adc	r14, r1
 39c:	f1 1c       	adc	r15, r1
 39e:	c1 ce       	rjmp	.-638    	; 0x122 <main+0x90>
		}
	
		{		//condition for U-Turns
			//edit here
			
			if(num == 31)
 3a0:	0f 31       	cpi	r16, 0x1F	; 31
 3a2:	11 05       	cpc	r17, r1
 3a4:	09 f0       	breq	.+2      	; 0x3a8 <main+0x316>
 3a6:	bd ce       	rjmp	.-646    	; 0x122 <main+0x90>
			{
				counter = counter + 1;
 3a8:	4f 5f       	subi	r20, 0xFF	; 255
 3aa:	5f 4f       	sbci	r21, 0xFF	; 255
				if((counter == 1)||(counter == 2))
 3ac:	ca 01       	movw	r24, r20
 3ae:	01 97       	sbiw	r24, 0x01	; 1
 3b0:	02 97       	sbiw	r24, 0x02	; 2
 3b2:	50 f4       	brcc	.+20     	; 0x3c8 <main+0x336>
				{
					PORTD |= (1<<5)|(1<<7);
 3b4:	82 b3       	in	r24, 0x12	; 18
 3b6:	80 6a       	ori	r24, 0xA0	; 160
 3b8:	82 bb       	out	0x12, r24	; 18
					PORTD &= (~((1<<4)|(1<<6)));
 3ba:	82 b3       	in	r24, 0x12	; 18
 3bc:	8f 7a       	andi	r24, 0xAF	; 175
 3be:	82 bb       	out	0x12, r24	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 3c0:	c4 01       	movw	r24, r8
 3c2:	01 97       	sbiw	r24, 0x01	; 1
 3c4:	f1 f7       	brne	.-4      	; 0x3c2 <main+0x330>
 3c6:	ad ce       	rjmp	.-678    	; 0x122 <main+0x90>
					_delay_ms(1);
					continue;
				}
				directions[counter123] = 'u';
 3c8:	fb 01       	movw	r30, r22
 3ca:	ee 0d       	add	r30, r14
 3cc:	ff 1d       	adc	r31, r15
 3ce:	85 e7       	ldi	r24, 0x75	; 117
 3d0:	80 83       	st	Z, r24
				counter++;
 3d2:	4f 5f       	subi	r20, 0xFF	; 255
 3d4:	5f 4f       	sbci	r21, 0xFF	; 255
 3d6:	a5 ce       	rjmp	.-694    	; 0x122 <main+0x90>
		short len = counter123-1;
		short m = 0;			//loop tracking variable
		short n = 0;			//assigning variable
		for(;m<=len;m++)
		{
			if(directions[m] != 'u')
 3d8:	f6 01       	movw	r30, r12
 3da:	e4 0f       	add	r30, r20
 3dc:	f5 1f       	adc	r31, r21
 3de:	20 81       	ld	r18, Z
 3e0:	25 37       	cpi	r18, 0x75	; 117
 3e2:	39 f0       	breq	.+14     	; 0x3f2 <main+0x360>
			{
				//simply copy over
				path[n] = directions[m];
 3e4:	fc 01       	movw	r30, r24
 3e6:	e6 0f       	add	r30, r22
 3e8:	f7 1f       	adc	r31, r23
 3ea:	20 83       	st	Z, r18
				n++;
 3ec:	6f 5f       	subi	r22, 0xFF	; 255
 3ee:	7f 4f       	sbci	r23, 0xFF	; 255
 3f0:	1d c0       	rjmp	.+58     	; 0x42c <main+0x39a>
			}
			
			else
			{
				//check for possiblities  lul = s,lus = r,sul = r
				if(path[n-1] == 's')
 3f2:	61 50       	subi	r22, 0x01	; 1
 3f4:	70 40       	sbci	r23, 0x00	; 0
 3f6:	dc 01       	movw	r26, r24
 3f8:	a6 0f       	add	r26, r22
 3fa:	b7 1f       	adc	r27, r23
 3fc:	6f 5f       	subi	r22, 0xFF	; 255
 3fe:	7f 4f       	sbci	r23, 0xFF	; 255
 400:	2c 91       	ld	r18, X
 402:	23 37       	cpi	r18, 0x73	; 115
 404:	11 f4       	brne	.+4      	; 0x40a <main+0x378>
				{
					//replace by r straight off
					path[n-1] = 'r';
 406:	bc 92       	st	X, r11
 408:	11 c0       	rjmp	.+34     	; 0x42c <main+0x39a>
					//don't change n
				}
				else if(path[n-1] == 'l')
 40a:	2c 36       	cpi	r18, 0x6C	; 108
 40c:	79 f4       	brne	.+30     	; 0x42c <main+0x39a>
				{
					if(directions[m+1] == 'l')
 40e:	9a 01       	movw	r18, r20
 410:	2f 5f       	subi	r18, 0xFF	; 255
 412:	3f 4f       	sbci	r19, 0xFF	; 255
 414:	f6 01       	movw	r30, r12
 416:	e2 0f       	add	r30, r18
 418:	f3 1f       	adc	r31, r19
 41a:	e0 81       	ld	r30, Z
 41c:	ec 36       	cpi	r30, 0x6C	; 108
 41e:	11 f4       	brne	.+4      	; 0x424 <main+0x392>
					{
						m = m + 1;
						path[n-1] = 's';
 420:	ac 92       	st	X, r10
 422:	05 c0       	rjmp	.+10     	; 0x42e <main+0x39c>
					}
					else if(directions[m+1] == 's')
 424:	e3 37       	cpi	r30, 0x73	; 115
 426:	11 f4       	brne	.+4      	; 0x42c <main+0x39a>
					{
						m = m + 1;
						path[n-1] = 'r';
 428:	bc 92       	st	X, r11
 42a:	01 c0       	rjmp	.+2      	; 0x42e <main+0x39c>
 42c:	9a 01       	movw	r18, r20
	char path[10];
	{
		short len = counter123-1;
		short m = 0;			//loop tracking variable
		short n = 0;			//assigning variable
		for(;m<=len;m++)
 42e:	a9 01       	movw	r20, r18
 430:	4f 5f       	subi	r20, 0xFF	; 255
 432:	5f 4f       	sbci	r21, 0xFF	; 255
 434:	e4 16       	cp	r14, r20
 436:	f5 06       	cpc	r15, r21
 438:	7c f6       	brge	.-98     	; 0x3d8 <main+0x346>
 43a:	8f ef       	ldi	r24, 0xFF	; 255
 43c:	9f ef       	ldi	r25, 0xFF	; 255
 43e:	29 e1       	ldi	r18, 0x19	; 25
 440:	30 e0       	ldi	r19, 0x00	; 0
 442:	f9 01       	movw	r30, r18
 444:	31 97       	sbiw	r30, 0x01	; 1
 446:	f1 f7       	brne	.-4      	; 0x444 <main+0x3b2>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 448:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 44a:	d9 f7       	brne	.-10     	; 0x442 <main+0x3b0>
 44c:	20 e0       	ldi	r18, 0x00	; 0
 44e:	30 e0       	ldi	r19, 0x00	; 0
 450:	64 ec       	ldi	r22, 0xC4	; 196
 452:	66 2e       	mov	r6, r22
 454:	69 e0       	ldi	r22, 0x09	; 9
 456:	76 2e       	mov	r7, r22
			if(num == 28 || num == 24 || num ==  7 || num == 3 || num == 0 || num == 31)
			{
				PORTD = 0x00;
				_delay_ms(10);
				//follow path array
				if(path[loopy] == 'l')
 458:	5b e0       	ldi	r21, 0x0B	; 11
 45a:	85 2e       	mov	r8, r21
 45c:	91 2c       	mov	r9, r1
 45e:	8c 0e       	add	r8, r28
 460:	9d 1e       	adc	r9, r29
 462:	4c e4       	ldi	r20, 0x4C	; 76
 464:	a4 2e       	mov	r10, r20
 466:	4d e1       	ldi	r20, 0x1D	; 29
 468:	b4 2e       	mov	r11, r20
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 46a:	46 ed       	ldi	r20, 0xD6	; 214
 46c:	56 e0       	ldi	r21, 0x06	; 6
 46e:	63 e0       	ldi	r22, 0x03	; 3
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 470:	94 ef       	ldi	r25, 0xF4	; 244
 472:	c9 2e       	mov	r12, r25
 474:	91 e0       	ldi	r25, 0x01	; 1
 476:	d9 2e       	mov	r13, r25
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 478:	89 e1       	ldi	r24, 0x19	; 25
 47a:	e8 2e       	mov	r14, r24
 47c:	f1 2c       	mov	r15, r1
 47e:	76 e0       	ldi	r23, 0x06	; 6
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 480:	a2 ee       	ldi	r26, 0xE2	; 226
 482:	b4 e0       	ldi	r27, 0x04	; 4
	//and now move along the necessary path.......
	short loopy = 0;
	while(1)
	{
			{								//block to assign status to num
				if((PINA & (1<<0)) != 0)
 484:	c8 9b       	sbis	0x19, 0	; 25
 486:	03 c0       	rjmp	.+6      	; 0x48e <__stack+0x2f>
				{
					num &= (~(1<<4));
 488:	c8 01       	movw	r24, r16
 48a:	8f 7e       	andi	r24, 0xEF	; 239
 48c:	02 c0       	rjmp	.+4      	; 0x492 <__stack+0x33>
				}
				else
				{
					num |= (1<<4);
 48e:	c8 01       	movw	r24, r16
 490:	80 61       	ori	r24, 0x10	; 16
				}


				if((PINA & (1<<1)) != 0)
 492:	c9 9b       	sbis	0x19, 1	; 25
 494:	02 c0       	rjmp	.+4      	; 0x49a <__stack+0x3b>
				{
					num &= (~(1<<3));
 496:	87 7f       	andi	r24, 0xF7	; 247
 498:	01 c0       	rjmp	.+2      	; 0x49c <__stack+0x3d>
				}
				else
				{
					num |= (1<<3);
 49a:	88 60       	ori	r24, 0x08	; 8
				}

				if((PINA & (1<<2)) != 0)
 49c:	ca 9b       	sbis	0x19, 2	; 25
 49e:	02 c0       	rjmp	.+4      	; 0x4a4 <__stack+0x45>
				{
					num &= (~(1<<2));
 4a0:	8b 7f       	andi	r24, 0xFB	; 251
 4a2:	01 c0       	rjmp	.+2      	; 0x4a6 <__stack+0x47>
				}
				else
				{
					num |= (1<<2);
 4a4:	84 60       	ori	r24, 0x04	; 4
				}

				if((PINA & (1<<3)) != 0)
 4a6:	cb 9b       	sbis	0x19, 3	; 25
 4a8:	02 c0       	rjmp	.+4      	; 0x4ae <__stack+0x4f>
				{
					num &= (~(1<<1));
 4aa:	8d 7f       	andi	r24, 0xFD	; 253
 4ac:	01 c0       	rjmp	.+2      	; 0x4b0 <__stack+0x51>
				}
				else
				{
					num |= (1<<1);
 4ae:	82 60       	ori	r24, 0x02	; 2
				}

				if((PINA & (1<<4)) != 0)
 4b0:	cc 9b       	sbis	0x19, 4	; 25
 4b2:	03 c0       	rjmp	.+6      	; 0x4ba <__stack+0x5b>
				{
					num &= (~(1<<0));
 4b4:	8c 01       	movw	r16, r24
 4b6:	0e 7f       	andi	r16, 0xFE	; 254
 4b8:	02 c0       	rjmp	.+4      	; 0x4be <__stack+0x5f>
				}
				else
				{
					num |= (1<<0);
 4ba:	8c 01       	movw	r16, r24
 4bc:	01 60       	ori	r16, 0x01	; 1
				}
			}					//end of status assigning block


			{  //line following code
				if(num == 4)
 4be:	04 30       	cpi	r16, 0x04	; 4
 4c0:	11 05       	cpc	r17, r1
 4c2:	71 f4       	brne	.+28     	; 0x4e0 <__stack+0x81>
				{
					//00100->full speed forward
					PORTD |= (1<<5)|(1<<7);
 4c4:	82 b3       	in	r24, 0x12	; 18
 4c6:	80 6a       	ori	r24, 0xA0	; 160
 4c8:	82 bb       	out	0x12, r24	; 18
					PORTD &= (~((1<<4)|(1<<6)));
 4ca:	82 b3       	in	r24, 0x12	; 18
 4cc:	8f 7a       	andi	r24, 0xAF	; 175
 4ce:	82 bb       	out	0x12, r24	; 18
 4d0:	ca 01       	movw	r24, r20
 4d2:	01 97       	sbiw	r24, 0x01	; 1
 4d4:	f1 f7       	brne	.-4      	; 0x4d2 <__stack+0x73>
					_delay_ms(7);
					PORTD = 0x00;
 4d6:	12 ba       	out	0x12, r1	; 18
 4d8:	cd 01       	movw	r24, r26
 4da:	01 97       	sbiw	r24, 0x01	; 1
 4dc:	f1 f7       	brne	.-4      	; 0x4da <__stack+0x7b>
 4de:	2a c0       	rjmp	.+84     	; 0x534 <__stack+0xd5>
					_delay_ms(5);
				}
				else if((num == 12) || (num == 8))
 4e0:	0c 30       	cpi	r16, 0x0C	; 12
 4e2:	11 05       	cpc	r17, r1
 4e4:	19 f0       	breq	.+6      	; 0x4ec <__stack+0x8d>
 4e6:	08 30       	cpi	r16, 0x08	; 8
 4e8:	11 05       	cpc	r17, r1
 4ea:	49 f4       	brne	.+18     	; 0x4fe <__stack+0x9f>
				{
					//01100 or 01000->take a mild left
					PORTD |= (1<<5);
 4ec:	95 9a       	sbi	0x12, 5	; 18
					PORTD &= (~(1<<4));
 4ee:	94 98       	cbi	0x12, 4	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 4f0:	86 2f       	mov	r24, r22
 4f2:	8a 95       	dec	r24
 4f4:	f1 f7       	brne	.-4      	; 0x4f2 <__stack+0x93>
					_delay_us(10);
					PORTD = 0x00;
 4f6:	12 ba       	out	0x12, r1	; 18
					PORTD |= (1<<7);
 4f8:	97 9a       	sbi	0x12, 7	; 18
					PORTD &= (~(1<<6));
 4fa:	96 98       	cbi	0x12, 6	; 18
 4fc:	0e c0       	rjmp	.+28     	; 0x51a <__stack+0xbb>
					_delay_us(20);
					PORTD = 0x00;
				}
				else if((num == 2) || (num == 6))
 4fe:	02 30       	cpi	r16, 0x02	; 2
 500:	11 05       	cpc	r17, r1
 502:	19 f0       	breq	.+6      	; 0x50a <__stack+0xab>
 504:	06 30       	cpi	r16, 0x06	; 6
 506:	11 05       	cpc	r17, r1
 508:	61 f4       	brne	.+24     	; 0x522 <__stack+0xc3>
				{
					//00010 or 00110->Take a mild right
					PORTD |= (1<<7);
 50a:	97 9a       	sbi	0x12, 7	; 18
					PORTD &= (~(1<<6));
 50c:	96 98       	cbi	0x12, 6	; 18
 50e:	86 2f       	mov	r24, r22
 510:	8a 95       	dec	r24
 512:	f1 f7       	brne	.-4      	; 0x510 <__stack+0xb1>
					_delay_us(10);
					PORTD = 0x00;
 514:	12 ba       	out	0x12, r1	; 18
					PORTD |= (1<<5);
 516:	95 9a       	sbi	0x12, 5	; 18
					PORTD &= (~(1<<4));
 518:	94 98       	cbi	0x12, 4	; 18
 51a:	87 2f       	mov	r24, r23
 51c:	8a 95       	dec	r24
 51e:	f1 f7       	brne	.-4      	; 0x51c <__stack+0xbd>
					_delay_us(20);
					PORTD = 0x00;
 520:	12 ba       	out	0x12, r1	; 18
				}

			}	//end of line following code
		
			//now turns and intersections
			if(num == 28 || num == 24 || num ==  7 || num == 3 || num == 0 || num == 31)
 522:	0c 31       	cpi	r16, 0x1C	; 28
 524:	11 05       	cpc	r17, r1
 526:	81 f0       	breq	.+32     	; 0x548 <__stack+0xe9>
 528:	08 31       	cpi	r16, 0x18	; 24
 52a:	11 05       	cpc	r17, r1
 52c:	69 f0       	breq	.+26     	; 0x548 <__stack+0xe9>
 52e:	07 30       	cpi	r16, 0x07	; 7
 530:	11 05       	cpc	r17, r1
 532:	51 f0       	breq	.+20     	; 0x548 <__stack+0xe9>
 534:	03 30       	cpi	r16, 0x03	; 3
 536:	11 05       	cpc	r17, r1
 538:	39 f0       	breq	.+14     	; 0x548 <__stack+0xe9>
 53a:	01 15       	cp	r16, r1
 53c:	11 05       	cpc	r17, r1
 53e:	21 f0       	breq	.+8      	; 0x548 <__stack+0xe9>
 540:	0f 31       	cpi	r16, 0x1F	; 31
 542:	11 05       	cpc	r17, r1
 544:	09 f0       	breq	.+2      	; 0x548 <__stack+0xe9>
 546:	9e cf       	rjmp	.-196    	; 0x484 <__stack+0x25>
			{
				PORTD = 0x00;
 548:	12 ba       	out	0x12, r1	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 54a:	c3 01       	movw	r24, r6
 54c:	01 97       	sbiw	r24, 0x01	; 1
 54e:	f1 f7       	brne	.-4      	; 0x54c <__stack+0xed>
				_delay_ms(10);
				//follow path array
				if(path[loopy] == 'l')
 550:	f4 01       	movw	r30, r8
 552:	e2 0f       	add	r30, r18
 554:	f3 1f       	adc	r31, r19
 556:	e0 81       	ld	r30, Z
 558:	ec 36       	cpi	r30, 0x6C	; 108
 55a:	d1 f4       	brne	.+52     	; 0x590 <__stack+0x131>
 55c:	80 e1       	ldi	r24, 0x10	; 16
 55e:	97 e2       	ldi	r25, 0x27	; 39
 560:	f7 01       	movw	r30, r14
 562:	31 97       	sbiw	r30, 0x01	; 1
 564:	f1 f7       	brne	.-4      	; 0x562 <__stack+0x103>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 566:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
 568:	d9 f7       	brne	.-10     	; 0x560 <__stack+0x101>
					//Take left here
					
					
					_delay_ms(1000);
					//go ahead a bit
					PORTD |= (1<<5)|(1<<7);
 56a:	82 b3       	in	r24, 0x12	; 18
 56c:	80 6a       	ori	r24, 0xA0	; 160
 56e:	82 bb       	out	0x12, r24	; 18
					PORTD &= (~((1<<4)|(1<<6)));
 570:	82 b3       	in	r24, 0x12	; 18
 572:	8f 7a       	andi	r24, 0xAF	; 175
 574:	82 bb       	out	0x12, r24	; 18
 576:	ca 01       	movw	r24, r20
 578:	01 97       	sbiw	r24, 0x01	; 1
 57a:	f1 f7       	brne	.-4      	; 0x578 <__stack+0x119>
					_delay_ms(07);
					PORTD = 0x00;
 57c:	12 ba       	out	0x12, r1	; 18
					//now take a turn till middle sensor is on black again...
					while(1)
					{
						PORTD |= (1<<7);
 57e:	97 9a       	sbi	0x12, 7	; 18
						PORTD &= (~(1<<6));
 580:	96 98       	cbi	0x12, 6	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 582:	86 2f       	mov	r24, r22
 584:	8a 95       	dec	r24
 586:	f1 f7       	brne	.-4      	; 0x584 <__stack+0x125>
						_delay_us(10);
						PORTD = 0x00;
 588:	12 ba       	out	0x12, r1	; 18
						if((PINA & (1<<2)) == 0)
 58a:	ca 99       	sbic	0x19, 2	; 25
 58c:	f8 cf       	rjmp	.-16     	; 0x57e <__stack+0x11f>
 58e:	24 c0       	rjmp	.+72     	; 0x5d8 <__stack+0x179>
							break;		//break out of while loop
					}		//left turn completed!!!
					
					loopy++;
				}
				else if(path[loopy] == 'r')
 590:	e2 37       	cpi	r30, 0x72	; 114
 592:	b1 f4       	brne	.+44     	; 0x5c0 <__stack+0x161>
				{
					//take right here
					PORTD |= (1<<5)|(1<<7);
 594:	82 b3       	in	r24, 0x12	; 18
 596:	80 6a       	ori	r24, 0xA0	; 160
 598:	82 bb       	out	0x12, r24	; 18
					PORTD &= (~((1<<4)|(1<<6)));
 59a:	82 b3       	in	r24, 0x12	; 18
 59c:	8f 7a       	andi	r24, 0xAF	; 175
 59e:	82 bb       	out	0x12, r24	; 18
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 5a0:	ca 01       	movw	r24, r20
 5a2:	01 97       	sbiw	r24, 0x01	; 1
 5a4:	f1 f7       	brne	.-4      	; 0x5a2 <__stack+0x143>
					_delay_ms(07);
					PORTD = 0x00;
 5a6:	12 ba       	out	0x12, r1	; 18
					while(1)
					{
						PORTD |= (1<<5);
 5a8:	95 9a       	sbi	0x12, 5	; 18
						PORTD &= (~(1<<4));
 5aa:	94 98       	cbi	0x12, 4	; 18
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
 5ac:	86 2f       	mov	r24, r22
 5ae:	8a 95       	dec	r24
 5b0:	f1 f7       	brne	.-4      	; 0x5ae <__stack+0x14f>
						_delay_us(10);
						PORTD = 0x00;
 5b2:	12 ba       	out	0x12, r1	; 18
						
						if((PINA & (1<<2)) == 0)
 5b4:	ca 99       	sbic	0x19, 2	; 25
 5b6:	f8 cf       	rjmp	.-16     	; 0x5a8 <__stack+0x149>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
 5b8:	c6 01       	movw	r24, r12
 5ba:	01 97       	sbiw	r24, 0x01	; 1
 5bc:	f1 f7       	brne	.-4      	; 0x5ba <__stack+0x15b>
 5be:	0c c0       	rjmp	.+24     	; 0x5d8 <__stack+0x179>
					}
					
					
					loopy++;
				}
				else if(path[loopy] == 's')
 5c0:	e3 37       	cpi	r30, 0x73	; 115
 5c2:	69 f4       	brne	.+26     	; 0x5de <__stack+0x17f>
				{
					//go straight
					PORTD |= (1<<5)|(1<<7);
 5c4:	82 b3       	in	r24, 0x12	; 18
 5c6:	80 6a       	ori	r24, 0xA0	; 160
 5c8:	82 bb       	out	0x12, r24	; 18
					PORTD &= (~((1<<4)|(1<<6)));
 5ca:	82 b3       	in	r24, 0x12	; 18
 5cc:	8f 7a       	andi	r24, 0xAF	; 175
 5ce:	82 bb       	out	0x12, r24	; 18
 5d0:	c5 01       	movw	r24, r10
 5d2:	01 97       	sbiw	r24, 0x01	; 1
 5d4:	f1 f7       	brne	.-4      	; 0x5d2 <__stack+0x173>
					_delay_ms(30);
					PORTD = 0x00;
 5d6:	12 ba       	out	0x12, r1	; 18
					loopy++;
 5d8:	2f 5f       	subi	r18, 0xFF	; 255
 5da:	3f 4f       	sbci	r19, 0xFF	; 255
 5dc:	53 cf       	rjmp	.-346    	; 0x484 <__stack+0x25>
				}
				else if(loopy == 'e')
 5de:	25 36       	cpi	r18, 0x65	; 101
 5e0:	31 05       	cpc	r19, r1
 5e2:	09 f0       	breq	.+2      	; 0x5e6 <__stack+0x187>
 5e4:	4f cf       	rjmp	.-354    	; 0x484 <__stack+0x25>
				{
					//stop
					PORTD = 0x00;
 5e6:	12 ba       	out	0x12, r1	; 18
				}
				
			}

	}
}
 5e8:	80 e0       	ldi	r24, 0x00	; 0
 5ea:	90 e0       	ldi	r25, 0x00	; 0
 5ec:	64 96       	adiw	r28, 0x14	; 20
 5ee:	0f b6       	in	r0, 0x3f	; 63
 5f0:	f8 94       	cli
 5f2:	de bf       	out	0x3e, r29	; 62
 5f4:	0f be       	out	0x3f, r0	; 63
 5f6:	cd bf       	out	0x3d, r28	; 61
 5f8:	cf 91       	pop	r28
 5fa:	df 91       	pop	r29
 5fc:	1f 91       	pop	r17
 5fe:	0f 91       	pop	r16
 600:	ff 90       	pop	r15
 602:	ef 90       	pop	r14
 604:	df 90       	pop	r13
 606:	cf 90       	pop	r12
 608:	bf 90       	pop	r11
 60a:	af 90       	pop	r10
 60c:	9f 90       	pop	r9
 60e:	8f 90       	pop	r8
 610:	7f 90       	pop	r7
 612:	6f 90       	pop	r6
 614:	5f 90       	pop	r5
 616:	4f 90       	pop	r4
 618:	3f 90       	pop	r3
 61a:	2f 90       	pop	r2
 61c:	08 95       	ret

0000061e <_exit>:
 61e:	f8 94       	cli

00000620 <__stop_program>:
 620:	ff cf       	rjmp	.-2      	; 0x620 <__stop_program>
